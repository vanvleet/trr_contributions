# Process Injection via Asynchronous Procedure Call (APC)

## Metadata

| Key          | Value                                      |
|--------------|--------------------------------------------|
| ID           | TRR0025                                    |
| External IDs | [T1055.004], [T1055.001], [T1055.002]      |
| Tactics      | Defense Evasion, Privilege Escalation      |
| Platforms    | Windows                                    |
| Contributors | Andrew VanVleet                            |

### Scope Statement

The ATT&CK framework is inconsistent in how it defines sub-techniques for
process injection[^1], resulting in a confusing mapping of TRRs to ATT&CK
techniques. This TRR primarily addresses Process Injection using Asynchronous
Procedure Calls (APCs), which is T1055.004, but this technique can be used to
inject any kind of payload, including PEs and DLLs, so the TRR also covers
aspects of Dynamic-link Library Injection (T1055.001) and Portable Executable
Injection (T1055.002).


## Technique Overview

Adversaries may inject code into other processes in order to evade defenses and
potentially elevate privileges. Running code in another process's context allows
access to that process's memory, resources, and privileges.

## Technical Background

### Multithreading

As a quick refresher on multithreaded computing: A process must have at least
one thread and can contain many threads running simultaneously. Each processor
has a set of registers and other structures (the translation lookaside buffer
and page table, for example) that are used during execution to store values and
the state of the executing thread. The values held in the registers and other
structures are called the thread's "context." All of a process's threads share
the process's virtual memory space but maintain their own operating context.

The operating system scheduler is responsible for scheduling all the threads
currently running on a system to ensure each gets their share of time executing
on one of the system's processors (most modern computers have multiple
processors). The scheduler will designate a thread to run on a given processor,
and then after a certain amount of time the thread's execution will be
interrupted, and another thread will be scheduled to run. When a change is made
from one thread to another, a "context switch" must happen, where the values of
the interrupted thread's context are saved out and the values from the context
of the next thread are loaded in. Once the context has been switched, the new
thread can resume executing at exactly the spot where it was previously
interrupted. Multithreading allows many threads to share computing resources
while still functioning as though it had a dedicated processor.

### Asynchronous Procedure Calls (APCs)

An APC is a function that executes asynchronously in the context of a particular
thread. When an APC is queued to a thread, the operating system issues a
software interrupt. The next time the thread is scheduled on a processor, it
will run the APC function before it resumes normal execution. An APC generated
by the system is called a kernel-mode APC. An APC generated by an application is
called a user-mode APC. When a user-mode APC is queued, the thread to which it
is queued is not directed to call the APC function until it is in an "alertable"
state.

### Alertable State

A thread enters an alertable state when it pauses active execution to wait for
something, like the completion of I/O request, the availability of a
synchronization object, the expiration of a certain amount of time, etc.
Functions that place the thread in an alertable state include `SleepEx`,
`SignalObjectAndWait`, `MsgWaitForMultipleObjectsEx`,
`WaitForMultipleObjectsEx`, and `WaitForSingleObjectEx`. Additionally, the
Windows routine that initializes every new user-mode thread checks to see if
there are any queued APCs and will execute them before transferring control to
the thread's entry point (this check happens in the function call `NtTestAlert`,
which is invoked by `LdrInitializeThunk`).

In order to use an APC for a process injection, an attacker has to target a
thread that is known to enter an alertable state and might have to wait an
unknown amount of time before the code executes. The [Early Bird injection]
approach solves this problem by creating a suspended process, queuing the APC to
the main (and only) thread, and then resuming the process, ensuring that the
malicious APC routine will get executed immediately.

The .NET Common Language Runtime (CLR) will always call `WaitForSingleObjectEx`
as part tearing down a .NET process, which means that a .NET process' main
thread is guaranteed to become alertable at some point before terminating.[^2]
That makes .NET processes a good choice as a target for an APC injection because
an attacker can know in advance that a thread will eventually become alertable.

### APC Injection

In order to use an APC callback, an attacker must write their desired code into
the target process using any available method. Common methods are allocating
memory in the target process with `VirtualAllocEx` or by mapping in a shared
section using `NtMapViewOfSection`. There are other ways to accomplish the same
goal. For example, "Atom Bombing" uses [atom tables] to transfer the desired
code into the target process. Once the code is present in the target process,
the attacker queues an APC to one of the process's threads using the

`QueueUserApc` or `NtQueueUserApc` functions, providing the address of the
injected function as one of the parameters. When the thread is directed to run
the APC, it will execute the injected code.

Here is the function definition for `QueueUserApc`:

```c++
    DWORD QueueUserAPC(
       [in] PAPCFUNC pfnAPC,  //This is a pointer to (the address of) the APC function that should be executed. This will be the address of the malicious payload in the target process.
       [in] HANDLE hThread,  //This is a handle to the target thread.

       [in] ULONG_PTR dwData  //This is a single parameter that can be provided to the APC function.

    );
```

## Procedures

| ID                  | Title            | Tactic            |
|---------------------|------------------|-------------------|
| TRR0025.WIN.A       | Queue Remote APC | Defense Evasion, Privilege Escalation    |

### Procedure A: Queue Remote APC

This procedure is defined by the mechanism used to achieve code execution in a
remote process. There are many options for the target process, including an
existing or newly created one, and many options for writing the injected code
into the target process's memory. The DDM identifies many common approaches but
does not attempt to be exhaustive. The critical element is the "Queue APC"
operation, which is absolutely essential for this procedure.

#### Detection Data Model

The operations in gray are optional. An attacker can simply wait for a thread to
become alertable, or they can trigger the APC to be called by creating a new
thread or resuming a recently created suspended thread.

![DDM - Queue Remote APC](ddms/trr0025_a.png)

## Available Emulation Tests

| ID            | Link             |
|---------------|------------------|
| TRR0025.WIN.A | [Atomic Tests #1-3]       |

## References

- [APC Injection]
- [Early Bird Injection]
- [Curious Case of QueueUserApc - Dwight Hohnstein]
- [What ATT&CK Gets Wrong About Process Injection - Andrew VanVleet]

[^1]: [What ATT&CK Gets Wrong About Process Injection - Andrew VanVleet]
[^2]: [Curious Case of QueueUserApc - Dwight Hohnstein]

[T1055.001]: https://attack.mitre.org/techniques/T1055/001
[T1055.002]: https://attack.mitre.org/techniques/T1055/002
[T1055.004]: https://attack.mitre.org/techniques/T1055/004
[Atomic Tests #1-3]: https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1055.004/T1055.004.md
[atom tables]: https://learn.microsoft.com/en-us/windows/win32/dataxchg/about-atom-tables
[Early Bird Injection]: https://www.ired.team/offensive-security/code-injection-process-injection/early-bird-apc-queue-code-injection
[APC Injection]: https://www.ired.team/offensive-security/code-injection-process-injection/apc-queue-code-injection
[Curious Case of QueueUserApc - Dwight Hohnstein]: https://medium.com/@djhohnstein
[What ATT&CK Gets Wrong About Process Injection - Andrew VanVleet]: https://medium.com/@vanvleet/ddm-use-case-what-att-ck-gets-wrong-about-process-injection-7c15b6764bfe
